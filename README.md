### 短信平台项目
#### 一 整体架构
>我们是一个分布式的项目,采用Spring Cloud 的方式进行开发,
> 注册中心暂时使用Eureka,各个服务的配置可以保存在配置中心中
> 
>  服务间的调用使用openfeign


### 二 各个功能
#### 2.1 注册中心
>用于保存所有的服务器列表
##### 2.1.1 platform-eureka
>这个是本项目的注册中心

```yaml
spring:
  application:
    name: platform-eureka
server:
  port: 10000
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10000/eureka
    fetch-registry: false
    register-with-eureka: false #使用的单机的
    region: 华北
```

#### 2.2 配置中心
>项目会分很多个模块,每个模块分很多个机器,一旦配置文件发生变化,需要更新很多个服务器,维护起来非常不方便
>我们使用的是config配合gitlab仓库实现

##### 2.2.1 platform-config
>这个是我们项目中统一配置中心的服务端, 配置文件保存在git中,然后通过注册中心进行注册,客户端通过服务发现找到配置中心拉取配置


#### 2.3 缓存模块
>我们的项目有大量的地方需要通过缓存来获取数据,所以我们将缓存单独剥离出来作为一个服务,方便修改扩展
>缓存使用的是redis来实现的
>对redis 的api进行封装  底层采用redisTemplate调用api 

##### 2.3.1 platform-cache
>这个是我们的缓存的模块,然后在内部进行缓存的相关操作
>因为redis 的配置会放在配置中心,所以需要bootstrap文件来帮忙加载配置文件
##### 2.3.2 bootstrap.yml

```yaml
#在当亲文件中进行配置文件的初始化,在线读取配置,因为我们的程序在启动起来进行对象初始化的时候就必须有配置了
eureka:
  client:
    service-url:
      defaultZone: http://localhost:10000/eureka
    region: 华北
spring:
  application:
    name: platform-cache
  cloud:
    config:
      discovery:
        enabled: true #开启注册中心的服务发现,也就是从注册中心获取配置中心服务器的相关信息
        service-id: platform-config
      profile: dev #实际查找的文件叫 platform-cache-dev.yml
#  redis:
#    host: xxx  #放到配置中心拉取
#    port: xxx
#    password: xxx
```

##### 2.3.3 序列化方式
>我们的项目中对缓存的操作会保存各种类型的数据, 那么到底以什么统一的格式保存到redis中呢? 我们此处选了key是string,value是json的方式

```java
 @Bean
    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();

        StringRedisSerializer keySerializer = new StringRedisSerializer();//这是一个string类型的序列化方式
        redisTemplate.setKeySerializer(keySerializer);
        redisTemplate.setHashKeySerializer(keySerializer);

        Jackson2JsonRedisSerializer<Object> jsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
        redisTemplate.setValueSerializer(jsonRedisSerializer);//我们的value到底如何序列化成内容,比如我们以json的方式,就需要一个json类型的序列化
        redisTemplate.setHashValueSerializer(jsonRedisSerializer);

        return redisTemplate;
    }

```


#### 2.4 接口模块(初步校验)
>当前模块的主要作用是接收客户群体发来的请求,请求的目的是给指定的手机号码发送指定的内容

##### 2.4.1 主要功能
1. ip过滤
> 有客户在我们的平台上注册充值了,目的发送短信,结果账号和密码泄露了,有人伪装是这个客户来进行发送短信的操作
> 我们为了尽量避免出现该情况,所以我们应该做一个处理措施,即便是访问者在知道账号密码的情况下也不能发送短信

2. 手机号校验
> 客户传递过来的手机号很有可能不符合规则,虽然客户可能会有前端校验等等措施,但是我们为了保证安全健壮性我们一定要校验
> 客户可能会传递多个手机号过来,我们需要将多个手机号进行分拆,从一个字符串(数组)转成多个字符串

3. 账号密码的过滤
> 我们需要对发送短信的人的信息进行校验,不能随便就允许别人发送短信,需要进行相应校验措施

4. 短信内容长度
>短信的长度是有限制的,不会无限制的长,我们需要对内容进行长度检测,如果超出长度则拆分短信为多条

5. 状态返回
> 客户通过我们发送的短信的最终结果到底是成功还是失败, 失败的原因是什么,我们都需要告诉客户,所以这边还有返回结果的操作,但是有些结果并不是实时返回的


#### 2.5 策略模块(内容校验)
> 策略的作用是通过不同的策略将信息进行相关的操作,比如判断手机号码是不是黑名单,有没有敏感词,有没有钱,有没有限流
> 包括数据的补全, 省市信息等进行补全
> 策略模块需要做的事情非常多但有多少并不确定,那么就出现了一个问题,我们到底执行什么策略?
> 如果增加了一个策略,导致代码发生重大变化怎么办?
> 最好的方式是不管有什么策略,你增加也好,减少也好,
> 甚至调整顺序也好,我们预先写好的代码不变,只是单纯增加策略类即可
> 所以采用责任链模式,类似filter一样的实现


##### 2.5.1 流程
> 策略模块会从MQ中获取所有的消息,第一给事情需要先连接MQ,拿到消息后需要经过策略模块的处理,就需要用上面的思路来对消息进行处理

##### 2.5.2 黑名单处理

> 黑名单是通过 BLACK:手机号的方式作为key保存到redis中的,所以我们可以通过 将手机号拼接 BLACK:的方式去查询

> 如果存储的方式换一个,则判断方式也跟着换, 比如我可以用一个key 将所有的黑名单保存起来到redis的set,然后判断手机号在不在这个set中

>策略模块在程序启动的时候从redis中同步一份黑名单过来,保存在本地, 后面进行判断的时候从本地判断



##### 2.5.3 敏感词
> 在内容中不允许出现的内容叫敏感词
> 如何判断内容中有敏感词, 首先我们得先知道我们的敏感词是什么
> ,然后通过内容的包含关系来判断内容中是否包含指定数据, 字符串的contains()
> 但是数据量大以后效率低下,故此引入DFA算法
> 牺牲一定空间做缓存树处理,增加效率



##### 2.5.4 限流
> 针对同一个客户向同一个手机号进行发送的次数限制,比如1分钟2次,一小时5次, 一天10次,这个值可以动态变化
> 当然客户也可以指定自己每天最多发多少条短信,超出后不再发送,此处我们暂时设置统一的限流机制,后续可以增加针对不同客户不同限流机制的措施

> 如果数据保存在redis,首先要确定的是key是什么,当前的策略是每个客户针对某个手机号的,
> 比如建设银行给13888888888发送的次数不应该影响工商银行给13888888888发送
> 那么这个key就必须包含 客户信息和手机号信息 比如客户id:手机号
> 当我们确定了key之后,需要确定value的类型,zset  key:value:score
> 我们以当前发送短信的时间为分数, 去查询指定时间分数范围内的数据长度是不是在限制的范围内,如果不是被限制的
> 则发送短信,并将当前时间作为分数随便设置一个value 保存到zset

##### 2.5.5 限流的自定义
> 我们限流的标准, 比如多少次 是可以定义的, 但是时间呢? 比如我们默认1分钟2条, 我们可以将条数自定义,通过查询缓存来获取, 但是我们如果想把限流改成五分钟三次
> 我们代码中写的时间固定是1 分钟 1小时, 1天,说明代码中的时间也不能直接写死, 而是可以通过某种方式获取
> 比如我们保存到zset, 以某个固定值如limitparam作为key, 以限流的时间作为 score,以次数作为值保存起来
> 这样我们可以通过查询这个zset获取到所有的限流的时间和次数 ,比如我们保存了一个 300 3 意味着是5分钟内限制3次
> 而且因为时间的天然顺序原因,我们的不同的限流措施还可以排序,比如 5分钟的和2小时的在这个zset中顺序可以排序


##### 2.5.6 号段补全
> 在产品的需求中,我们可能会对目标手机号的区域进行一些操作,比如发送的短信号码中,有三分之一发送到了北京,那我们可以去和北京的运营商谈合作,市内短信相对比较便宜,所以可以多加几个对应地区的合作商
> 那么问题来了,在什么地方能找到手机号属于什么地区(既然需要统计,就需要保存数据,数据在哪里保存了),我们在短信的内容对象中设置了两个属性,一个是省id,一个是市id,我们只需要给这两个数据设置值即可
> 在缓存中,给每个号段设置了一个key,value是对应的省市id,我们可以根据手机号的前7位来获取这个数据




#### 2.6 webMaster 
>管理后台
